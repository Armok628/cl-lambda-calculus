(defvar K '(L (X Y) X))
(defvar S '(L (X Y Z) ((X Z) (Y Z))))
(defvar Y '(L (F) ((L (X) (F (X X))) (L (X) (F (X X)))))); Untested
(defvar ltrue '(L (X Y) X))
(defvar lfalse '(L (X Y) Y))
(defvar lnot `(L (C) ((C ,lfalse) ,ltrue)))
(defvar lor `(L (X Y) ((X ,ltrue) Y)))
(defvar lif `(L (A B C) ((A B) C)))
(defvar ladd `(L (A B) (A F (B F X))))
(defvar lmult `(L (A B) (A (B F) X)))

(defun subst-assoc (l env)
  (cond ((listp l) (mapcar (lambda (x) (subst-assoc x env)) l))
	((and (symbolp l) (assoc l env)) (cdr (assoc l env)))
	(t l)))

(defun alpha-convert (func)
  (subst-assoc func (loop for sym in (cadr func)
			  collect (cons sym (gensym)))))

(defun l-apply (func args)
  (setf func (alpha-convert func))
  (let ((env (loop for a in (cadr func) for b in args collect (cons a b))))
    (if (> (length (cadr func)) (length args))
      `(l ,(nthcdr (length args) (cadr func))
	  ,@(subst-assoc (cddr func) env))
      (car (subst-assoc (cddr func) env)))))

(defun beta-reduce (redex)
  (cond ((atom redex) redex)
	((eq (car redex) 'l) redex)
	((atom (car redex)) redex)
	((eq (caar redex) 'l)
	 (l-apply (car redex) (mapcar #'beta-reduce (cdr redex))))
	(t (mapcar #'beta-reduce redex))))

(defun church-numeral (n &key (init nil))
  (declare (type fixnum n))
  (cond ((not init) (list 'L '(F X) (church-numeral n :init t)))
	((zerop n) 'X)
	(t (list 'F (church-numeral (1- n) :init t)))))

(defun full-reduction (redex &optional (print-steps nil) (hist nil))
  (cond ((equal redex (car hist))
	 (when print-steps (format t "窿" (reverse hist)))
	 (values redex 'FINAL))
	((member redex (cdr hist) :test #'equal)
	 (when print-steps (format t "窿" (reverse hist)))
	 (values redex 'CYCLIC))
	(t (full-reduction (beta-reduce redex)
			   print-steps
			   `(,redex ,@hist)))))
